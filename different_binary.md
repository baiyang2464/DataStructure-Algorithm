## [不同的二叉搜索树](https://leetcode-cn.com/problems/unique-binary-search-trees/)

**题目**
给定一个整数 n，求以 1 ... n 为节点组成的二叉搜索树有多少种？

**示例**
![Alt text](./pictures/1561195274590.png)

**思路**
假设一共是n个节点，那么根节点是肯定有一个的。

剩下的n-1个节点则要分配给根节点的左子树和右子树，那么分给左子树的个数`left​`可能是`0或1或2.....或n-1​`；右边则是`(n-1)- left​`个。则可转化为计算更小规模的不同搜索树种数的问题--->动态规划/分治法

> 且注意：当给定个数为x的时候，这个二叉搜索树里面的数字不管是`1,2,3....x`还是`3,4,5,....,x+3`其实效果是一样的，我们只要考虑数字列的次序就可以了，它实际上是什么数字是不重要的。因此，对于1,2两个数字来说dp[2]=2；对于2,3两个数字来说dp[2]=2仍然是成立的。

另外还要注意某个根结点的搜索树种类等于左右两边子树的可能种数值相乘，不是相加。
动态规划转化公式：

![](./pictures/mylatex20190624_161853.png)

**代码**

```cpp
class Solution {
public:
    int numTrees(int n) {
        vector<int> dp(n+1,0);
        dp[0] = 1;//dp[0]要初始化为1，以使dp[0]*dp[n-1]不至为0
        dp[1] = 1;
        for(int i=2;i<=n;++i)
            for(int j=0;j<i;++j)
            {
                dp[i]+=dp[j]*dp[i-j-1];
            }
        return dp[n];
    }
};
```

