## 位运算

+ 位逻辑运算符：

`&` （位   “与”）  and

`^` （位   “异或”）

`|` （位    “或”）   or

`~` （位   “取反”）

+ 移位运算符：

`<<`（左移）

`>>`（右移）

+ 示例

`&`运算符

双目运算符，两边都为1，结果为1

```cpp
0&1 =0;   
0&0 =0;
1&0 =0;
1&1 =1;
00111 & 11100 =00100
&运算通常用于二进制取位操作，例如一个数 &1的结果就是取二进制的最末位。
取末三位	比如1101101取101	直接这样"nums & 7"就可以了
这可以用来判断一个整数的奇偶，二进制的最末位为0表示该数是偶数，最末位为1表示该数为奇数
```

`^`运算符

```
双目运算符，两边不同为1，相同为0
```

概念

如果我们对 0 和二进制位做 XOR 运算，得到的仍然是这个二进制位

`a^0=a`

如果我们对相同的二进制位做 XOR 运算，返回的结果是 0

`a^a=0`

XOR 满足交换律和结合律

`a^b^a=(a^a)^b=0^b=b`



`|`运算符

```
双目运算符，两边有一个1，结果就为1
算通常用于对二进制的特定一位进行取反操作，运算的逆运算是它本身，也就是说两次异或同一个数最后结果不变
即（a ^ b) ^ b=a；
```

`<<`左移运算符

```
a<<b 表示把a转为二进制后左移b位（在a的二进制表示的后面添加 b个0）。
例如100的二进制表示为1100100，100左移2位后（后面加2个零）：1100100<<2 =110010000 =400，
可以看出，a<<b的值实际上就是a乘以2的b次方，因为在二进制数后面添加一个0就相当该数乘以2

定义一些常量可能会用到<<运算。你可以方便的用1<<16 -1 来表示65535（unsingned int最大值16位系统）
```
`>>`右移运算符

```
右移相当于把原来的数除2
```



## 确定毒酒

**题目**

有8瓶酒，其中有一瓶有毒，可以取多瓶酒一小口导入一个杯子中给实验者品尝，一个实验者只能品尝一次，所有实验者只能同时品尝，问至少需要几个实验者一定可以在一次品尝中确定有毒的那瓶酒。

**思路**

这种问题一定要问原问题进行抽象，使解决问题可以用到计算机的专业知识。

若使可以品尝多次，其实可以考虑查找类的算法

但是所有实验者只能同时且不管中毒与否只有一次机会品尝，人数要尽量少的情况下，可以考虑对8瓶酒进行二进制编码，分别是：000,001,010,011,100,101,110,111 ，只用3位就可以表示8个数。

然后让实验者A尝编码高位为1的酒的混合，B尝编码第二位为1的酒的混合，C尝编码低位为1的酒的混合，既：

A:111,110,101,100

B:111,110,011,010

C:111,101,011,001

则若A死亡，则毒酒的编码肯定高位为1，若A 无事，则毒酒的编码肯定高位为0

例如A，B死亡，C无事，则毒酒编码为110，依此规则3个人就可以确定毒酒。

## [格雷编码](https://leetcode-cn.com/problems/gray-code/)

**题目：**

格雷编码是一个二进制数字系统，在该系统中，两个连续的数值仅有一个位数的差异。

给定一个代表编码总位数的非负整数 n，打印其格雷编码序列。格雷编码序列必须以 0 开头。

**例子：**

示例 1:

```
输入: 2
输出: [0,1,3,2]
解释:
00 - 0
01 - 1
11 - 3
10 - 2
对于给定的 n，其格雷编码序列并不唯一。
例如，[0,2,3,1] 也是一个有效的格雷编码序列。
00 - 0
10 - 2
11 - 3
01 - 1
```
示例 2:
```
输入: 0
输出: [0]
解释: 我们定义格雷编码序列必须以 0 开头。
给定编码总位数为 n 的格雷编码序列，其长度为 2n。当 n = 0 时，长度为 20 = 1。
因此，当 n = 0 时，其格雷编码序列为 [0]。
```
**解题：**

运用公式。。。i^(i>>1)，自己与自己右移一位进行异或，得到的就是它的格雷码。


```cpp
class Solution {
public:
    vector<int> grayCode(int n) {
        //格雷编码生成公式i ^ (i>>1)
        vector<int> res;
        int size = 1<<n;
        for(int i=0;i<size;++i)
        {
            res.push_back(i^(i>>1));
        }
        return res;
    }
};
```

## [只出现一次的数字](https://leetcode-cn.com/problems/single-number/)

给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。

说明：

你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？
```
示例 1:

输入: [2,2,1]
输出: 1

示例 2:

输入: [4,1,2,1,2]
输出: 4
```

**思路**

如果使用暴力法遍历数组同时去判断每个数在数组中有无重复元素，时间复杂度为O(n^2)，

若采用排序，之后在遍历一次找无重复元素，时间复杂度为O(nlogn)，

若使用hash表比如set，去重后求和，用公式2*(a+b+x)-(2a+2b+x) =x可以找出无重复元素x，空间复杂度为O(n)

都不符合题意要求

题目是要排除出现两次的元素，怎么把出现两次的元素消去？用异或

a^a=0

0^a=a

且异或符合交换律

`a^a^b=(a^a)^b=0^b=a^(a^b)=b`

**代码**

```c++
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        int res = nums[0];
        for(int i=1;i<nums.size();++i)
            res ^= nums[i];
        return res;
    }
};
```

## [只出现一次的数字-II](https://leetcode-cn.com/problems/single-number-ii/)

【这个问题还没搞得很透彻，解析是借鉴网上的博客】

给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现了三次。找出那个只出现了一次的元素。

说明：

你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？
```
示例 1:

输入: [2,2,3,2]
输出: 3
示例 2:

输入: [0,1,0,1,0,1,99]
输出: 99
```

**思路**

上一问题本质是想通过两个元素相互消除用到了异或。那么这个问题其实本质就是希望三个元素相互消除。我们不再是通过一个元素记录状态，而是通过两个元素来记录状态的转化。

希望达到下面的效果：

定义两个变量：ones，twos，在数字x出现1，2，3次时它们变化如下

```
变量	|x出现1次	|x出现2次	|x出现3次
ones |x		   |0        |0
twos |0        |x        |0
```

这样出现三次的数消为0，出现一次的数可以找出来

首先我们会定义两个变量a和b，当遍历nums的时候，对于重复元素x，第一次碰到x的时候，我们会将x赋给a，第二次碰到后再赋给b，第三次碰到就全部消除。赋值和消除的动作可以通过xor很简单的实现。所以我们就可以写出这样的代码

```
a = (a^num)
b = (b^num)
```

但是上面写法忽略了，只有当a是x的时候，我们会将0赋给b，那要怎么做呢？我们知道如果b=0，那么b^num就变成了x，而x&~x就完成了消除操作，而此时a=x，所以第二行写为
```
b = (b^num) & ~a
```
同理，我们应该将第一行改为
```
a = (a^num) & ~b
```
最后代码如下
```
class Solution:
    def singleNumber(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        ones, twos = 0, 0
        for num in nums:
            ones = (ones^num) & ~twos
            twos = (twos^num) & ~ones

        return ones
```

如果我们将问题继续推广成**如果输入数组中每个元素出现k次，只有一个元素出现p次，那个出现p次的元素是？**

看这篇[寻找特定数字问题](https://blog.csdn.net/qq_17550379/article/details/83926785)



## 开方函数

若系统不提供开方函数`sqrt`，请写一个浮点数的开方函数，`e`是要求的误差范围

输入：

```
一个浮点数：x
误差范围：e
```

输出：x的平方根，要求精度在正确值得正负e之内

思路：

使用牛顿迭代法

```c++
float mySqrt(float x,float e)
{
	float cur = x/2.0;
	float last = x;
	while(abs(last-cur)>e)
	{
		float tmp = (cur +x/cur)/2.0
		last = cur;
		cur = tmp;
	}
	return cur;
}
```

## [直线上最多的点数](https://leetcode-cn.com/problems/max-points-on-a-line/)

给定一个二维平面，平面上有 n 个点，求最多有多少个点在同一条直线上。

注意相同坐标值得点可能出现多次，它们算作不同的点。

示例 1:

```
输入: [[1,1],[2,2],[3,3]]
输出: 3
解释:
^
|
|        o
|     o
|  o  
+------------->
0  1  2  3  4
```
示例 2:
```
输入: [[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]
输出: 4
解释:
^
|
|  o
|     o        o
|        o
|  o        o
+------------------->
0  1  2  3  4  5  6
```

思路：

涉及到如何表示点，如何唯一的确定一条直线，如何表示点和直线的关系

一个方法是，若找到确定一条直线的标志，用一个字典的key存储标志，唯一的标识一条直线，然后values存储在这条直线上的点数目

表示一条直线的方法：

```
1.点斜式
以一个点为端点，从该点出发，计算其与其它点的斜率，就可以表示出经过该点的所有直线，其它点在直线上出现的次数也可统计出来

2.一般式
y=kx+b，记录点对之间形成的k和b值，来标识一条直线
```

下面使用点斜式的思路来解这道题

```python
class Solution:
    def maxPoints(self, points: List[List[int]]) -> int:
        dict1 = {} # 记录点重复出现的次数
        for point in points:
            dict1[(point[0],point[1])] = dict1.get((point[0],point[1]),0)+1
        keys = list(dict1.keys()) # 换成list，方便j从i+1起步   
        res = 0
        if len(keys) >=1:
            res = dict1[keys[0]]
        for i,(x,y) in enumerate(keys):    
            # 每个点都作为一个标定点，去计算它与其他点的斜率 
            # 同时应知道，一个点加一个斜率（点斜式），就可以确定平面的一条直线
            dict2 = {} # 存储其它点在某条直线上出现的次数
            for j in range(i+1,len(keys)): 
                _x,_y = keys[j][0],keys[j][1]
                k = 'inf' 
                if x!=_x: # 若斜率不为无限大
                    k = (_y-y)*10 / (_x-x) #放大处理,增大精度,为了跑通最后一组数据
                dict2[k]  = dict2.get(k,0) + dict1[keys[j]]  
            if dict2:
                res = max(res,dict1[keys[i]]+max(dict2.values()))    
                # 从一个点出发可以找到它所在的直线上的所有点，用res记录已经出现的直线上的最多的点数
        return res      
```

