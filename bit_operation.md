## 位运算

+ 位逻辑运算符：

`&` （位   “与”）  and
`^` （位   “异或”）
`|` （位    “或”）   or
`~` （位   “取反”）

+ 移位运算符：

`<<`（左移）
`>>`（右移）

+ 示例

`&`运算符

双目运算符，两边都为1，结果为1

```cpp
0&1 =0;   
0&0 =0;
1&0 =0;
1&1 =1;
00111 & 11100 =00100
&运算通常用于二进制取位操作，例如一个数 &1的结果就是取二进制的最末位。
取末三位	比如1101101取101	直接这样"nums & 7"就可以了
这可以用来判断一个整数的奇偶，二进制的最末位为0表示该数是偶数，最末位为1表示该数为奇数
```

`^`运算符

```
双目运算符，两边不同为1，相同为0
```

`|`运算符

```
双目运算符，两边有一个1，结果就为1
算通常用于对二进制的特定一位进行取反操作，运算的逆运算是它本身，也就是说两次异或同一个数最后结果不变
即（a ^ b) ^ b=a；
```

`<<`左移运算符

```
a<<b 表示把a转为二进制后左移b位（在a的二进制表示的后面添加 b个0）。
例如100的二进制表示为1100100，100左移2位后（后面加2个零）：1100100<<2 =110010000 =400，
可以看出，a<<b的值实际上就是a乘以2的b次方，因为在二进制数后面添加一个0就相当该数乘以2

定义一些常量可能会用到<<运算。你可以方便的用1<<16 -1 来表示65535（unsingned int最大值16位系统）
```
`>>`右移运算符

```
右移相当于把原来的数除2
```



## 确定毒酒

**题目**

有8瓶酒，其中有一瓶有毒，可以取多瓶酒一小口导入一个杯子中给实验者品尝，一个实验者只能品尝一次，所有实验者只能同时品尝，问至少需要几个实验者一定可以在一次品尝中确定有毒的那瓶酒。

**思路**

这种问题一定要问原问题进行抽象，使解决问题可以用到计算机的专业知识。

若使可以品尝多次，其实可以考虑查找类的算法

但是所有实验者只能同时且不管中毒与否只有一次机会品尝，人数要尽量少的情况下，可以考虑对8瓶酒进行二进制编码，分别是：000,001,010,011,100,101,110,111 ，只用3位就可以表示8个数。

然后让实验者A尝编码高位为1的酒的混合，B尝编码第二位为1的酒的混合，C尝编码低位为1的酒的混合，既：

A:111,110,101,100

B:111,110,011,010

C:111,101,011,001

则若A死亡，则毒酒的编码肯定高位为1，若A 无事，则毒酒的编码肯定高位为0

例如A，B死亡，C无事，则毒酒编码为110，依此规则3个人就可以确定毒酒。

## [格雷编码](https://leetcode-cn.com/problems/gray-code/)

**题目：

格雷编码是一个二进制数字系统，在该系统中，两个连续的数值仅有一个位数的差异。

给定一个代表编码总位数的非负整数 n，打印其格雷编码序列。格雷编码序列必须以 0 开头。

**例子：**

示例 1:

```
输入: 2
输出: [0,1,3,2]
解释:
00 - 0
01 - 1
11 - 3
10 - 2
对于给定的 n，其格雷编码序列并不唯一。
例如，[0,2,3,1] 也是一个有效的格雷编码序列。
00 - 0
10 - 2
11 - 3
01 - 1
```
示例 2:
```
输入: 0
输出: [0]
解释: 我们定义格雷编码序列必须以 0 开头。
给定编码总位数为 n 的格雷编码序列，其长度为 2n。当 n = 0 时，长度为 20 = 1。
因此，当 n = 0 时，其格雷编码序列为 [0]。
```
**解题：**

运用公式。。。i^(i>>1)，自己与自己右移一位进行异或，得到的就是它的格雷码。


```cpp
class Solution {
public:
    vector<int> grayCode(int n) {
        //格雷编码生成公式i ^ (i>>1)
        vector<int> res;
        int size = 1<<n;
        for(int i=0;i<size;++i)
        {
            res.push_back(i^(i>>1));
        }
        return res;
    }
};
```
